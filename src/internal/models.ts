//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           2.4.6
//
//
//       bebopc source:
//           https://github.com/RainwayApp/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError } from "bebop";

export interface IFullMessage {
  topic: string;
  data: string;
}

export const FullMessage = {
  discriminator: 1 as 1,
  encode(message: IFullMessage): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IFullMessage, view: BebopView): number {
    const before = view.length;
      view.writeString(message.topic);
      view.writeString(message.data);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IFullMessage {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IFullMessage {
    let field0: string;
    field0 = view.readString();
    let field1: string;
    field1 = view.readString();
    let message: IFullMessage = {
      topic: field0,
      data: field1,
    };
    return message;
  },
};

export interface ISplitMessageHeader {
  id: string;
  topic: string;
  parts: number;
  data: string;
}

export const SplitMessageHeader = {
  discriminator: 2 as 2,
  encode(message: ISplitMessageHeader): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: ISplitMessageHeader, view: BebopView): number {
    const before = view.length;
      view.writeGuid(message.id);
      view.writeString(message.topic);
      view.writeUint16(message.parts);
      view.writeString(message.data);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): ISplitMessageHeader {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): ISplitMessageHeader {
    let field0: string;
    field0 = view.readGuid();
    let field1: string;
    field1 = view.readString();
    let field2: number;
    field2 = view.readUint16();
    let field3: string;
    field3 = view.readString();
    let message: ISplitMessageHeader = {
      id: field0,
      topic: field1,
      parts: field2,
      data: field3,
    };
    return message;
  },
};

export interface ISplitMessagePart {
  id: string;
  index: number;
  data: string;
}

export const SplitMessagePart = {
  discriminator: 3 as 3,
  encode(message: ISplitMessagePart): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: ISplitMessagePart, view: BebopView): number {
    const before = view.length;
      view.writeGuid(message.id);
      view.writeUint16(message.index);
      view.writeString(message.data);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): ISplitMessagePart {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): ISplitMessagePart {
    let field0: string;
    field0 = view.readGuid();
    let field1: number;
    field1 = view.readUint16();
    let field2: string;
    field2 = view.readString();
    let message: ISplitMessagePart = {
      id: field0,
      index: field1,
      data: field2,
    };
    return message;
  },
};

export type IMessage
  = { discriminator: 1, value: IFullMessage }
  | { discriminator: 2, value: ISplitMessageHeader }
  | { discriminator: 3, value: ISplitMessagePart };

export const Message = {
  encode(message: IMessage): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    this.encodeInto(message, view);
    return view.toArray();
  },

  encodeInto(message: IMessage, view: BebopView): number {
    const before = view.length;
      const pos = view.reserveMessageLength();
      const start = view.length + 1;
      view.writeByte(message.discriminator);
      switch (message.discriminator) {
        case 1:
          FullMessage.encodeInto(message.value, view);
          break;
        case 2:
          SplitMessageHeader.encodeInto(message.value, view);
          break;
        case 3:
          SplitMessagePart.encodeInto(message.value, view);
          break;
      }
      const end = view.length;
      view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  },

  decode(buffer: Uint8Array): IMessage {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return this.readFrom(view);
  },

  readFrom(view: BebopView): IMessage {
    const length = view.readMessageLength();
    const end = view.index + 1 + length;
    switch (view.readByte()) {
      case 1:
        return { discriminator: 1, value: FullMessage.readFrom(view) };
      case 2:
        return { discriminator: 2, value: SplitMessageHeader.readFrom(view) };
      case 3:
        return { discriminator: 3, value: SplitMessagePart.readFrom(view) };
      default:
        view.index = end;
        throw new BebopRuntimeError("Unrecognized discriminator while decoding Message");
    }
  },
};

